"use strict";(globalThis.webpackChunkjobmetric_document=globalThis.webpackChunkjobmetric_document||[]).push([[8572],{28453(e,a,t){t.d(a,{R:()=>d,x:()=>s});var n=t(96540);const i={},l=n.createContext(i);function d(e){const a=n.useContext(l);return n.useMemo(function(){return"function"==typeof e?e(a):{...a,...e}},[a,e])}function s(e){let a;return a=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:d(e.components),n.createElement(l.Provider,{value:a},e.children)}},95320(e,a,t){t.r(a),t.d(a,{assets:()=>c,contentTitle:()=>r,default:()=>h,frontMatter:()=>s,metadata:()=>n,toc:()=>o});const n=JSON.parse('{"id":"laravel-metadata/deep-diving/has-dynamic-meta","title":"HasDynamicMeta","description":"The HasDynamicMeta trait integrates with custom field systems to automatically manage allowed metadata keys based on model types. It dynamically determines which metadata keys are allowed based on the model\'s type field.","source":"@site/packages/laravel-metadata/deep-diving/has-dynamic-meta.md","sourceDirName":"laravel-metadata/deep-diving","slug":"/laravel-metadata/deep-diving/has-dynamic-meta","permalink":"/packages/laravel-metadata/deep-diving/has-dynamic-meta","draft":false,"unlisted":false,"editUrl":"https://github.com/jobmetric/document/blob/master/packages/laravel-metadata/deep-diving/has-dynamic-meta.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3,"sidebar_label":"HasDynamicMeta"},"sidebar":"packagesSidebar","previous":{"title":"HasFilterMeta","permalink":"/packages/laravel-metadata/deep-diving/has-filter-meta"},"next":{"title":"Meta","permalink":"/packages/laravel-metadata/deep-diving/models/meta"}}');var i=t(74848),l=t(28453),d=t(28774);const s={sidebar_position:3,sidebar_label:"HasDynamicMeta"},r="HasDynamicMeta",c={},o=[{value:"Namespace",id:"namespace",level:2},{value:"Overview",id:"overview",level:2},{value:"Basic Usage",id:"basic-usage",level:2},{value:"Attach Trait to Model",id:"attach-trait-to-model",level:3},{value:"Available Methods",id:"available-methods",level:2},{value:"Metadata Allow Fields",id:"metadata-allow-fields",level:3},{value:"Dynamic Meta Field Type Name",id:"dynamic-meta-field-type-name",level:3},{value:"How It Works",id:"how-it-works",level:2},{value:"Complete Examples",id:"complete-examples",level:2},{value:"Product with Type-Based Metadata",id:"product-with-type-based-metadata",level:3},{value:"Integration with HasMeta",id:"integration-with-hasmeta",level:3},{value:"Related Documentation",id:"related-documentation",level:2}];function m(e){const a={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,l.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(a.header,{children:(0,i.jsx)(a.h1,{id:"hasdynamicmeta",children:"HasDynamicMeta"})}),"\n",(0,i.jsxs)(a.p,{children:["The ",(0,i.jsx)(a.code,{children:"HasDynamicMeta"})," trait integrates with custom field systems to automatically manage allowed metadata keys based on model types. It dynamically determines which metadata keys are allowed based on the model's type field."]}),"\n",(0,i.jsx)(a.h2,{id:"namespace",children:"Namespace"}),"\n",(0,i.jsx)(a.pre,{children:(0,i.jsx)(a.code,{className:"language-php",children:"JobMetric\\Metadata\\HasDynamicMeta\n"})}),"\n",(0,i.jsx)(a.h2,{id:"overview",children:"Overview"}),"\n",(0,i.jsxs)(a.p,{children:["The ",(0,i.jsx)(a.code,{children:"HasDynamicMeta"})," trait is designed to work with type-based systems where different model types have different allowed metadata keys. It automatically loads allowed keys from a service type system and makes them available for metadata validation."]}),"\n",(0,i.jsx)(a.h2,{id:"basic-usage",children:"Basic Usage"}),"\n",(0,i.jsx)(a.h3,{id:"attach-trait-to-model",children:"Attach Trait to Model"}),"\n",(0,i.jsx)(a.pre,{children:(0,i.jsx)(a.code,{className:"language-php",children:"use JobMetric\\Metadata\\HasDynamicMeta;\nuse JobMetric\\Metadata\\HasMeta;\n\nclass Product extends Model\n{\n    use HasMeta, HasDynamicMeta;\n\n    // The field name that contains the type\n    // Default is 'type'\n    public function dynamicMetaFieldTypeName(): string\n    {\n        return 'type'; // or 'category', 'product_type', etc.\n    }\n}\n"})}),"\n",(0,i.jsx)(a.h2,{id:"available-methods",children:"Available Methods"}),"\n",(0,i.jsx)(a.h3,{id:"metadata-allow-fields",children:"Metadata Allow Fields"}),"\n",(0,i.jsx)(a.p,{children:"Get the allowed metadata fields for the current model instance based on its type:"}),"\n",(0,i.jsx)(a.pre,{children:(0,i.jsx)(a.code,{className:"language-php",children:"$allowedFields = $product->metadataAllowFields();\n// => ['color', 'size', 'weight'] (based on product type)\n"})}),"\n",(0,i.jsxs)(a.p,{children:[(0,i.jsx)(a.strong,{children:"Returns:"})," ",(0,i.jsx)(a.code,{children:"array"})," - Array of allowed metadata keys"]}),"\n",(0,i.jsx)(a.h3,{id:"dynamic-meta-field-type-name",children:"Dynamic Meta Field Type Name"}),"\n",(0,i.jsx)(a.p,{children:"Override this method to specify which field contains the type:"}),"\n",(0,i.jsx)(a.pre,{children:(0,i.jsx)(a.code,{className:"language-php",children:"public function dynamicMetaFieldTypeName(): string\n{\n    return 'type'; // Default\n}\n"})}),"\n",(0,i.jsxs)(a.p,{children:[(0,i.jsx)(a.strong,{children:"Returns:"})," ",(0,i.jsx)(a.code,{children:"string"})," - Field name containing the type"]}),"\n",(0,i.jsx)(a.h2,{id:"how-it-works",children:"How It Works"}),"\n",(0,i.jsxs)(a.ol,{children:["\n",(0,i.jsx)(a.li,{children:"On model boot, the trait loads metadata definitions from the service type system"}),"\n",(0,i.jsx)(a.li,{children:"It groups allowed keys by model type"}),"\n",(0,i.jsxs)(a.li,{children:["When ",(0,i.jsx)(a.code,{children:"metadataAllowFields()"})," is called, it returns keys for the model's current type"]}),"\n",(0,i.jsxs)(a.li,{children:["These keys can be used with ",(0,i.jsx)(a.code,{children:"HasMeta"})," to restrict allowed metadata"]}),"\n"]}),"\n",(0,i.jsx)(a.h2,{id:"complete-examples",children:"Complete Examples"}),"\n",(0,i.jsx)(a.h3,{id:"product-with-type-based-metadata",children:"Product with Type-Based Metadata"}),"\n",(0,i.jsx)(a.pre,{children:(0,i.jsx)(a.code,{className:"language-php",children:"use JobMetric\\Metadata\\HasMeta;\nuse JobMetric\\Metadata\\HasDynamicMeta;\n\nclass Product extends Model\n{\n    use HasMeta, HasDynamicMeta;\n\n    protected $fillable = ['name', 'type'];\n\n    public function dynamicMetaFieldTypeName(): string\n    {\n        return 'type';\n    }\n}\n\n// Product with type 'clothing' allows: color, size, material\n// Product with type 'electronics' allows: brand, model, warranty\n\n$clothing = Product::create(['name' => 'T-Shirt', 'type' => 'clothing']);\n$allowed = $clothing->metadataAllowFields();\n// => ['color', 'size', 'material']\n\n$electronics = Product::create(['name' => 'Laptop', 'type' => 'electronics']);\n$allowed = $electronics->metadataAllowFields();\n// => ['brand', 'model', 'warranty']\n"})}),"\n",(0,i.jsx)(a.h3,{id:"integration-with-hasmeta",children:"Integration with HasMeta"}),"\n",(0,i.jsx)(a.pre,{children:(0,i.jsx)(a.code,{className:"language-php",children:"class Product extends Model\n{\n    use HasMeta, HasDynamicMeta;\n\n    protected function initializeHasMeta(): void\n    {\n        parent::initializeHasMeta();\n        \n        // Merge dynamic metadata keys\n        $this->mergeMeta($this->metadataAllowFields());\n    }\n}\n"})}),"\n",(0,i.jsx)(a.h2,{id:"related-documentation",children:"Related Documentation"}),"\n",(0,i.jsxs)(a.ul,{children:["\n",(0,i.jsxs)(a.li,{children:["\n",(0,i.jsx)(d.A,{to:"/packages/laravel-metadata/deep-diving/has-meta",children:"HasMeta"}),"\n"]}),"\n",(0,i.jsxs)(a.li,{children:["\n",(0,i.jsx)(d.A,{to:"/packages/laravel-metadata/deep-diving/models/meta",children:"Meta Model"}),"\n"]}),"\n"]})]})}function h(e={}){const{wrapper:a}={...(0,l.R)(),...e.components};return a?(0,i.jsx)(a,{...e,children:(0,i.jsx)(m,{...e})}):m(e)}}}]);