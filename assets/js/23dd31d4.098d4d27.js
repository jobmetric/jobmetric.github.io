"use strict";(globalThis.webpackChunkjobmetric_document=globalThis.webpackChunkjobmetric_document||[]).push([[9042],{1332(e,n,t){t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>u,frontMatter:()=>i,metadata:()=>r,toc:()=>d});const r=JSON.parse('{"id":"laravel-flow/deep-diving/support/flow-task-context","title":"FlowTaskContext","description":"The FlowTaskContext class provides runtime context for flow task execution. It carries all relevant data needed by tasks during transition execution, including the subject model, transition result, payload, user, and task configuration.","source":"@site/packages/laravel-flow/deep-diving/support/flow-task-context.md","sourceDirName":"laravel-flow/deep-diving/support","slug":"/laravel-flow/deep-diving/support/flow-task-context","permalink":"/packages/laravel-flow/deep-diving/support/flow-task-context","draft":false,"unlisted":false,"editUrl":"https://github.com/jobmetric/document/blob/master/packages/laravel-flow/deep-diving/support/flow-task-context.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"sidebar_position":4,"sidebar_label":"FlowTaskContext"},"sidebar":"packagesSidebar","previous":{"title":"FlowPickerBuilder","permalink":"/packages/laravel-flow/deep-diving/support/flow-picker-builder"},"next":{"title":"RestrictionResult","permalink":"/packages/laravel-flow/deep-diving/support/restriction-result"}}');var s=t(4848),a=t(8453);const i={sidebar_position:4,sidebar_label:"FlowTaskContext"},o="FlowTaskContext",l={},d=[{value:"Namespace",id:"namespace",level:2},{value:"Overview",id:"overview",level:2},{value:"Constructor",id:"constructor",level:2},{value:"Basic Usage",id:"basic-usage",level:3},{value:"Parameters",id:"parameters",level:3},{value:"Accessing Context Data",id:"accessing-context-data",level:2},{value:"subject()",id:"subject",level:3},{value:"result()",id:"result",level:3},{value:"payload()",id:"payload",level:3},{value:"user()",id:"user",level:3},{value:"config()",id:"config",level:3},{value:"replaceConfig()",id:"replaceconfig",level:3},{value:"Understanding the Context Flow",id:"understanding-the-context-flow",level:2},{value:"How Context is Created and Passed",id:"how-context-is-created-and-passed",level:3},{value:"Complete Examples",id:"complete-examples",level:2},{value:"Example 1: Advanced Action Task - Order Processing",id:"example-1-advanced-action-task---order-processing",level:3},{value:"Example 2: Advanced Restriction Task - Multi-Condition Order Cancellation",id:"example-2-advanced-restriction-task---multi-condition-order-cancellation",level:3},{value:"Example 3: Advanced Validation Task - Dynamic Payment Validation",id:"example-3-advanced-validation-task---dynamic-payment-validation",level:3},{value:"Example 4: Complex Payload Processing - Order Status Update",id:"example-4-complex-payload-processing---order-status-update",level:3},{value:"Example 5: Advanced User Context Usage - Audit and Authorization",id:"example-5-advanced-user-context-usage---audit-and-authorization",level:3},{value:"Example 6: Comprehensive Result Management - Multi-Task Coordination",id:"example-6-comprehensive-result-management---multi-task-coordination",level:3},{value:"Example 7: Configuration Management - Testing and Overrides",id:"example-7-configuration-management---testing-and-overrides",level:3},{value:"Real-World Complete System Example",id:"real-world-complete-system-example",level:2},{value:"Complete Order Cancellation Workflow",id:"complete-order-cancellation-workflow",level:3},{value:"Integration with FlowTransition",id:"integration-with-flowtransition",level:2},{value:"Best Practices",id:"best-practices",level:2},{value:"Related Documentation",id:"related-documentation",level:2}];function c(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"flowtaskcontext",children:"FlowTaskContext"})}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"FlowTaskContext"})," class provides runtime context for flow task execution. It carries all relevant data needed by tasks during transition execution, including the subject model, transition result, payload, user, and task configuration."]}),"\n",(0,s.jsx)(n.h2,{id:"namespace",children:"Namespace"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-php",children:"JobMetric\\Flow\\Support\\FlowTaskContext\n"})}),"\n",(0,s.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,s.jsx)(n.p,{children:"The context provides access to:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Subject"}),": The main model instance the flow is operating on"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Result"}),": The ",(0,s.jsx)(n.code,{children:"TransitionResult"})," for collecting messages, errors, and data"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Payload"}),": Arbitrary input data from form or API request"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"User"}),": The authenticated user who triggered the transition"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Config"}),": Cached task configuration (avoiding database calls)"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"constructor",children:"Constructor"}),"\n",(0,s.jsx)(n.h3,{id:"basic-usage",children:"Basic Usage"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-php",children:"use JobMetric\\Flow\\Support\\FlowTaskContext;\nuse JobMetric\\Flow\\DTO\\TransitionResult;\n\n$subject = Order::find(1);\n$result = TransitionResult::success();\n$payload = ['reason' => 'Customer request'];\n$user = auth()->user();\n\n$context = new FlowTaskContext($subject, $result, $payload, $user);\n"})}),"\n",(0,s.jsx)(n.h3,{id:"parameters",children:"Parameters"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"Model $subject"}),": The main model instance"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"TransitionResult $result"}),": The transition result object"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"array $payload = []"}),": Input payload (optional)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"Authenticatable|null $user = null"}),": Authenticated user (optional)"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"accessing-context-data",children:"Accessing Context Data"}),"\n",(0,s.jsx)(n.h3,{id:"subject",children:"subject()"}),"\n",(0,s.jsx)(n.p,{children:"Get the main subject model:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-php",children:"$order = $context->subject();\n// Returns: Order model instance\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Returns:"})," ",(0,s.jsx)(n.code,{children:"Model"})," - The model the flow is operating on"]}),"\n",(0,s.jsx)(n.h3,{id:"result",children:"result()"}),"\n",(0,s.jsx)(n.p,{children:"Get the transition result:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-php",children:"$result = $context->result();\n$result->addMessage('Task completed');\n$result->setData('key', 'value');\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Returns:"})," ",(0,s.jsx)(n.code,{children:"TransitionResult"})," - The result object for this transition"]}),"\n",(0,s.jsx)(n.h3,{id:"payload",children:"payload()"}),"\n",(0,s.jsx)(n.p,{children:"Get the input payload:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-php",children:"$payload = $context->payload();\n$reason = $payload['reason'] ?? null;\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Returns:"})," ",(0,s.jsx)(n.code,{children:"array<string, mixed>"})," - Input payload from request"]}),"\n",(0,s.jsx)(n.h3,{id:"user",children:"user()"}),"\n",(0,s.jsx)(n.p,{children:"Get the authenticated user:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-php",children:"$user = $context->user();\nif ($user) {\n    $userId = $user->id;\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Returns:"})," ",(0,s.jsx)(n.code,{children:"Authenticatable|null"})," - The user who triggered the transition"]}),"\n",(0,s.jsx)(n.h3,{id:"config",children:"config()"}),"\n",(0,s.jsx)(n.p,{children:"Get the task configuration:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-php",children:"$config = $context->config();\n$emailTo = $config['email_to'] ?? null;\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Returns:"})," ",(0,s.jsx)(n.code,{children:"array<string, mixed>"})," - Task configuration (empty array if not set)"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Note:"})," No database calls are performed; returns cached configuration"]}),"\n",(0,s.jsx)(n.h3,{id:"replaceconfig",children:"replaceConfig()"}),"\n",(0,s.jsx)(n.p,{children:"Replace the in-memory configuration:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-php",children:"$context->replaceConfig([\n    'email_to' => 'user@example.com',\n    'template' => 'order-status',\n]);\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Use Cases:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Inject configuration from outside"}),"\n",(0,s.jsx)(n.li,{children:"Override configuration for testing"}),"\n",(0,s.jsx)(n.li,{children:"Avoid database calls"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Returns:"})," ",(0,s.jsx)(n.code,{children:"$this"})," (fluent interface)"]}),"\n",(0,s.jsx)(n.h2,{id:"understanding-the-context-flow",children:"Understanding the Context Flow"}),"\n",(0,s.jsx)(n.h3,{id:"how-context-is-created-and-passed",children:"How Context is Created and Passed"}),"\n",(0,s.jsxs)(n.p,{children:["When a transition is executed, ",(0,s.jsx)(n.code,{children:"FlowTransition"})," service automatically creates a ",(0,s.jsx)(n.code,{children:"FlowTaskContext"})," and passes it to each task:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-php",children:"// Inside FlowTransition::runner()\n$transitionResult = TransitionResult::success();\n$context = new FlowTaskContext(\n    $subject,           // The model (Order, Invoice, etc.)\n    $transitionResult,  // Shared result object\n    $payload,           // Request data\n    $user               // Authenticated user\n);\n\n// Tasks receive the same context instance\n$restrictionTask->restriction($context);  // First: Restriction checks\n$validationTask->rules($context);          // Second: Validation\n$actionTask->handle($context);             // Third: Actions\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Key Point:"})," All tasks in a transition share the ",(0,s.jsx)(n.strong,{children:"same"})," ",(0,s.jsx)(n.code,{children:"TransitionResult"})," object. This means:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Messages/errors from one task are visible to others"}),"\n",(0,s.jsx)(n.li,{children:"Data set by one task can be read by subsequent tasks"}),"\n",(0,s.jsx)(n.li,{children:"The final result aggregates all task outcomes"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"complete-examples",children:"Complete Examples"}),"\n",(0,s.jsx)(n.h3,{id:"example-1-advanced-action-task---order-processing",children:"Example 1: Advanced Action Task - Order Processing"}),"\n",(0,s.jsx)(n.p,{children:"A comprehensive action task that demonstrates using all context components:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-php",children:"namespace App\\Flows\\Order;\n\nuse App\\Mail\\OrderStatusChanged;\nuse App\\Notifications\\OrderProcessed;\nuse Illuminate\\Support\\Facades\\DB;\nuse Illuminate\\Support\\Facades\\Log;\nuse Illuminate\\Support\\Facades\\Mail;\nuse Illuminate\\Support\\Facades\\Queue;\nuse JobMetric\\Flow\\Contracts\\AbstractActionTask;\nuse JobMetric\\Flow\\Support\\FlowTaskContext;\nuse JobMetric\\Flow\\Support\\FlowTaskDefinition;\nuse JobMetric\\Form\\FormBuilder;\n\nclass ProcessOrderActionTask extends AbstractActionTask\n{\n    public static function subject(): string\n    {\n        return \\App\\Models\\Order::class;\n    }\n\n    public static function definition(): FlowTaskDefinition\n    {\n        return new FlowTaskDefinition(\n            title: 'flow::base.task.process_order.title',\n            description: 'Processes order and sends notifications',\n            icon: null,\n            tags: null,\n        );\n    }\n\n    public function form(): FormBuilder\n    {\n        return (new FormBuilder)\n            ->hiddenCustomField('send_email', 'boolean', true, 'Send email notification')\n            ->hiddenCustomField('send_sms', 'boolean', false, 'Send SMS notification')\n            ->hiddenCustomField('email_template', 'string', 'order-status', 'Email template name')\n            ->hiddenCustomField('queue_notifications', 'boolean', true, 'Queue notifications')\n            ->hiddenCustomField('log_activity', 'boolean', true, 'Log activity');\n    }\n\n    protected function handle(FlowTaskContext $context): void\n    {\n        // Get all context components\n        $order = $context->subject();        // Order model\n        $result = $context->result();       // Shared TransitionResult\n        $config = $context->config();        // Task configuration\n        $user = $context->user();            // User who triggered transition\n        $payload = $context->payload();      // Request payload\n\n        // Extract configuration with defaults\n        $sendEmail = $config['send_email'] ?? true;\n        $sendSms = $config['send_sms'] ?? false;\n        $emailTemplate = $config['email_template'] ?? 'order-status';\n        $queueNotifications = $config['queue_notifications'] ?? true;\n        $logActivity = $config['log_activity'] ?? true;\n\n        // Extract payload data\n        $reason = $payload['reason'] ?? 'Status changed';\n        $notes = $payload['notes'] ?? '';\n        $metadata = $payload['metadata'] ?? [];\n\n        try {\n            DB::beginTransaction();\n\n            // 1. Update order with payload data\n            if (isset($payload['notes'])) {\n                $order->notes = $notes;\n                $order->save();\n            }\n\n            // 2. Log activity if enabled\n            if ($logActivity) {\n                $this->logActivity($order, $user, $reason, $result);\n            }\n\n            // 3. Send email notification\n            if ($sendEmail) {\n                $this->sendEmailNotification($order, $user, $emailTemplate, $result);\n            }\n\n            // 4. Send SMS notification\n            if ($sendSms) {\n                $this->sendSmsNotification($order, $user, $result);\n            }\n\n            // 5. Queue additional notifications\n            if ($queueNotifications) {\n                $this->queueNotifications($order, $user, $result);\n            }\n\n            // 6. Update result with success information\n            $result->addMessage('Order processed successfully')\n                ->addMessage('Notifications sent')\n                ->setData('order_id', $order->id)\n                ->setData('new_status', $order->status)\n                ->setData('processed_at', now()->toIso8601String())\n                ->setMeta('email_sent', $sendEmail)\n                ->setMeta('sms_sent', $sendSms)\n                ->setMeta('execution_time', microtime(true) - LARAVEL_START);\n\n            DB::commit();\n\n        } catch (\\Exception $e) {\n            DB::rollBack();\n\n            // Add error to shared result\n            $result->addError('Failed to process order: ' . $e->getMessage())\n                ->setMeta('error_class', get_class($e))\n                ->setMeta('error_trace', $e->getTraceAsString());\n\n            // Log error\n            Log::error('Order processing failed', [\n                'order_id' => $order->id,\n                'error' => $e->getMessage(),\n                'user_id' => $user?->id,\n            ]);\n        }\n    }\n\n    protected function logActivity($order, $user, $reason, $result): void\n    {\n        activity()\n            ->performedOn($order)\n            ->causedBy($user)\n            ->withProperties([\n                'reason' => $reason,\n                'old_status' => $order->getOriginal('status'),\n                'new_status' => $order->status,\n            ])\n            ->log('Order status changed');\n\n        $result->addMessage('Activity logged')\n            ->setMeta('activity_logged', true);\n    }\n\n    protected function sendEmailNotification($order, $user, $template, $result): void\n    {\n        try {\n            $recipient = $user?->email ?? $order->customer_email;\n\n            if ($queueNotifications ?? true) {\n                Mail::to($recipient)->queue(new OrderStatusChanged($order, $template));\n            } else {\n                Mail::to($recipient)->send(new OrderStatusChanged($order, $template));\n            }\n\n            $result->addMessage(\"Email notification sent to {$recipient}\")\n                ->setMeta('email_recipient', $recipient)\n                ->setMeta('email_template', $template);\n\n        } catch (\\Exception $e) {\n            // Don't fail the entire task, just log the error\n            $result->addError('Email notification failed: ' . $e->getMessage(), false)\n                ->setMeta('email_error', $e->getMessage());\n        }\n    }\n\n    protected function sendSmsNotification($order, $user, $result): void\n    {\n        try {\n            $phone = $user?->phone ?? $order->customer_phone;\n\n            if ($phone) {\n                // Send SMS logic here\n                $result->addMessage(\"SMS notification sent to {$phone}\")\n                    ->setMeta('sms_sent_to', $phone);\n            }\n\n        } catch (\\Exception $e) {\n            $result->addError('SMS notification failed: ' . $e->getMessage(), false);\n        }\n    }\n\n    protected function queueNotifications($order, $user, $result): void\n    {\n        try {\n            // Queue additional notifications\n            if ($user) {\n                $user->notify(new OrderProcessed($order));\n            }\n\n            $result->setMeta('notifications_queued', true);\n\n        } catch (\\Exception $e) {\n            $result->addError('Failed to queue notifications: ' . $e->getMessage(), false);\n        }\n    }\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Key Points:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Uses all context components (subject, result, config, user, payload)"}),"\n",(0,s.jsxs)(n.li,{children:["Reads configuration from ",(0,s.jsx)(n.code,{children:"config()"})]}),"\n",(0,s.jsxs)(n.li,{children:["Extracts data from ",(0,s.jsx)(n.code,{children:"payload()"})]}),"\n",(0,s.jsxs)(n.li,{children:["Updates shared ",(0,s.jsx)(n.code,{children:"result()"})," object"]}),"\n",(0,s.jsx)(n.li,{children:"Handles errors gracefully without breaking the transition"}),"\n",(0,s.jsx)(n.li,{children:"Uses user information for logging and notifications"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"example-2-advanced-restriction-task---multi-condition-order-cancellation",children:"Example 2: Advanced Restriction Task - Multi-Condition Order Cancellation"}),"\n",(0,s.jsx)(n.p,{children:"A comprehensive restriction task that checks multiple conditions using all context components:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-php",children:"namespace App\\Flows\\Order;\n\nuse App\\Models\\Order;\nuse App\\Models\\User;\nuse Illuminate\\Support\\Facades\\Cache;\nuse Illuminate\\Support\\Facades\\DB;\nuse JobMetric\\Flow\\Contracts\\AbstractRestrictionTask;\nuse JobMetric\\Flow\\Support\\FlowTaskContext;\nuse JobMetric\\Flow\\Support\\FlowTaskDefinition;\nuse JobMetric\\Flow\\Support\\RestrictionResult;\nuse JobMetric\\Form\\FormBuilder;\n\nclass RestrictOrderCancellationRestrictionTask extends AbstractRestrictionTask\n{\n    public static function subject(): string\n    {\n        return \\App\\Models\\Order::class;\n    }\n\n    public static function definition(): FlowTaskDefinition\n    {\n        return new FlowTaskDefinition(\n            title: 'flow::base.task.restrict_cancellation.title',\n            description: 'Restricts order cancellation based on multiple conditions',\n            icon: null,\n            tags: null,\n        );\n    }\n\n    public function form(): FormBuilder\n    {\n        return (new FormBuilder)\n            ->hiddenCustomField('allow_cancellation_after_shipping', 'boolean', false, 'Allow cancellation after shipping')\n            ->hiddenCustomField('max_cancellation_hours', 'integer', 24, 'Maximum hours after creation to allow cancellation')\n            ->hiddenCustomField('require_cancellation_reason', 'boolean', true, 'Require cancellation reason')\n            ->hiddenCustomField('check_payment_status', 'boolean', true, 'Check payment status')\n            ->hiddenCustomField('check_inventory', 'boolean', true, 'Check inventory impact');\n    }\n\n    public function restriction(FlowTaskContext $context): RestrictionResult\n    {\n        // Get all context components\n        $order = $context->subject();\n        $user = $context->user();\n        $payload = $context->payload();\n        $config = $context->config();\n        $result = $context->result(); // Can add messages for debugging\n\n        // Extract configuration\n        $allowAfterShipping = $config['allow_cancellation_after_shipping'] ?? false;\n        $maxCancellationHours = $config['max_cancellation_hours'] ?? 24;\n        $requireReason = $config['require_cancellation_reason'] ?? true;\n        $checkPayment = $config['check_payment_status'] ?? true;\n        $checkInventory = $config['check_inventory'] ?? true;\n\n        // 1. Check user authentication\n        if (!$user) {\n            $result->addMessage('Restriction check: No authenticated user');\n            return RestrictionResult::deny(\n                'USER_NOT_AUTHENTICATED',\n                'You must be logged in to cancel orders'\n            );\n        }\n\n        // 2. Check user permission\n        if (!$user->can('cancel', $order)) {\n            $result->addMessage(\"Restriction check: User {$user->id} lacks cancel permission\");\n            return RestrictionResult::deny(\n                'PERMISSION_DENIED',\n                'You do not have permission to cancel this order'\n            );\n        }\n\n        // 3. Check order ownership (if applicable)\n        if ($order->user_id !== $user->id && !$user->hasRole('admin')) {\n            $result->addMessage(\"Restriction check: User {$user->id} does not own order {$order->id}\");\n            return RestrictionResult::deny(\n                'ORDER_OWNERSHIP_MISMATCH',\n                'You can only cancel your own orders'\n            );\n        }\n\n        // 4. Check order status\n        if ($order->status === 'shipped' && !$allowAfterShipping) {\n            $result->addMessage(\"Restriction check: Order {$order->id} is shipped\");\n            return RestrictionResult::deny(\n                'ORDER_SHIPPED',\n                'Cannot cancel shipped orders'\n            );\n        }\n\n        if ($order->status === 'delivered') {\n            $result->addMessage(\"Restriction check: Order {$order->id} is delivered\");\n            return RestrictionResult::deny(\n                'ORDER_DELIVERED',\n                'Cannot cancel delivered orders'\n            );\n        }\n\n        if ($order->status === 'cancelled') {\n            $result->addMessage(\"Restriction check: Order {$order->id} is already cancelled\");\n            return RestrictionResult::deny(\n                'ORDER_ALREADY_CANCELLED',\n                'Order is already cancelled'\n            );\n        }\n\n        // 5. Check time limit\n        $hoursSinceCreated = $order->created_at->diffInHours(now());\n        if ($hoursSinceCreated > $maxCancellationHours) {\n            $result->addMessage(\"Restriction check: Order {$order->id} exceeds time limit ({$hoursSinceCreated}h > {$maxCancellationHours}h)\");\n            return RestrictionResult::deny(\n                'TIME_LIMIT_EXCEEDED',\n                \"Orders can only be cancelled within {$maxCancellationHours} hours of creation\"\n            );\n        }\n\n        // 6. Check cancellation reason (from payload)\n        if ($requireReason && empty($payload['reason'])) {\n            $result->addMessage(\"Restriction check: Cancellation reason required but not provided\");\n            return RestrictionResult::deny(\n                'REASON_REQUIRED',\n                'Cancellation reason is required'\n            );\n        }\n\n        // 7. Check payment status\n        if ($checkPayment) {\n            if ($order->payment_status === 'refunded') {\n                return RestrictionResult::deny(\n                    'PAYMENT_ALREADY_REFUNDED',\n                    'Payment has already been refunded'\n                );\n            }\n\n            if ($order->payment_status === 'pending') {\n                // Allow cancellation if payment not yet processed\n                $result->addMessage(\"Restriction check: Payment pending, cancellation allowed\");\n            }\n        }\n\n        // 8. Check inventory impact (from payload or config)\n        if ($checkInventory) {\n            $restockInventory = $payload['restock_inventory'] ?? $config['restock_inventory'] ?? true;\n            \n            if ($restockInventory) {\n                // Check if inventory can be restocked\n                $canRestock = $this->canRestockInventory($order);\n                if (!$canRestock) {\n                    return RestrictionResult::deny(\n                        'INVENTORY_RESTOCK_FAILED',\n                        'Cannot cancel order: inventory cannot be restocked'\n                    );\n                }\n            }\n        }\n\n        // 9. Check for active disputes (custom business logic)\n        if ($this->hasActiveDispute($order)) {\n            $result->addMessage(\"Restriction check: Order {$order->id} has active dispute\");\n            return RestrictionResult::deny(\n                'ACTIVE_DISPUTE',\n                'Cannot cancel order with active dispute'\n            );\n        }\n\n        // 10. Check rate limiting (prevent abuse)\n        $cancellationCount = $this->getRecentCancellationCount($user);\n        if ($cancellationCount >= 5) {\n            return RestrictionResult::deny(\n                'RATE_LIMIT_EXCEEDED',\n                'Too many cancellations. Please contact support.'\n            );\n        }\n\n        // All checks passed\n        $result->addMessage(\"Restriction check: All conditions met for order {$order->id}\")\n            ->setMeta('cancellation_allowed', true)\n            ->setMeta('time_since_creation', $hoursSinceCreated)\n            ->setMeta('user_id', $user->id);\n\n        return RestrictionResult::allow();\n    }\n\n    protected function canRestockInventory(Order $order): bool\n    {\n        // Check if inventory items can be restocked\n        foreach ($order->items as $item) {\n            if (!$item->product->canRestock()) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    protected function hasActiveDispute(Order $order): bool\n    {\n        return $order->disputes()\n            ->where('status', 'open')\n            ->exists();\n    }\n\n    protected function getRecentCancellationCount(User $user): int\n    {\n        $cacheKey = \"user_cancellations_{$user->id}\";\n        \n        return Cache::remember($cacheKey, 3600, function () use ($user) {\n            return $user->orders()\n                ->where('status', 'cancelled')\n                ->where('updated_at', '>=', now()->subDays(30))\n                ->count();\n        });\n    }\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Key Points:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Uses all context components for comprehensive checks"}),"\n",(0,s.jsx)(n.li,{children:"Reads configuration to make restrictions configurable"}),"\n",(0,s.jsx)(n.li,{children:"Uses payload data for dynamic checks"}),"\n",(0,s.jsx)(n.li,{children:"Adds messages to result for debugging"}),"\n",(0,s.jsx)(n.li,{children:"Implements complex business logic"}),"\n",(0,s.jsx)(n.li,{children:"Handles edge cases and rate limiting"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"example-3-advanced-validation-task---dynamic-payment-validation",children:"Example 3: Advanced Validation Task - Dynamic Payment Validation"}),"\n",(0,s.jsx)(n.p,{children:"A comprehensive validation task that demonstrates dynamic rule generation based on context:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-php",children:"namespace App\\Flows\\Order;\n\nuse App\\Models\\Order;\nuse App\\Models\\User;\nuse Illuminate\\Support\\Facades\\DB;\nuse JobMetric\\Flow\\Contracts\\AbstractValidationTask;\nuse JobMetric\\Flow\\Support\\FlowTaskContext;\nuse JobMetric\\Flow\\Support\\FlowTaskDefinition;\nuse JobMetric\\Form\\FormBuilder;\n\nclass ValidatePaymentValidationTask extends AbstractValidationTask\n{\n    public static function subject(): string\n    {\n        return \\App\\Models\\Order::class;\n    }\n\n    public static function definition(): FlowTaskDefinition\n    {\n        return new FlowTaskDefinition(\n            title: 'flow::base.task.validate_payment.title',\n            description: 'Validates payment information before processing',\n            icon: null,\n            tags: null,\n        );\n    }\n\n    public function form(): FormBuilder\n    {\n        return (new FormBuilder)\n            ->hiddenCustomField('require_cvv', 'boolean', true, 'Require CVV for credit cards')\n            ->hiddenCustomField('require_billing_address', 'boolean', true, 'Require billing address')\n            ->hiddenCustomField('min_amount', 'decimal', 0, 'Minimum payment amount')\n            ->hiddenCustomField('max_amount', 'decimal', null, 'Maximum payment amount')\n            ->hiddenCustomField('allowed_payment_methods', 'array', ['credit_card', 'paypal'], 'Allowed payment methods');\n    }\n\n    public function rules(FlowTaskContext $context): array\n    {\n        // Get all context components\n        $order = $context->subject();\n        $user = $context->user();\n        $payload = $context->payload();\n        $config = $context->config();\n\n        // Extract configuration\n        $requireCvv = $config['require_cvv'] ?? true;\n        $requireBillingAddress = $config['require_billing_address'] ?? true;\n        $minAmount = $config['min_amount'] ?? 0;\n        $maxAmount = $config['max_amount'] ?? $order->total;\n        $allowedMethods = $config['allowed_payment_methods'] ?? ['credit_card', 'paypal'];\n\n        // Base rules\n        $rules = [\n            'payment_method' => [\n                'required',\n                'string',\n                'in:' . implode(',', $allowedMethods),\n            ],\n            'amount' => [\n                'required',\n                'numeric',\n                \"min:{$minAmount}\",\n                \"max:{$maxAmount}\",\n            ],\n        ];\n\n        // Dynamic rules based on payment method\n        $paymentMethod = $payload['payment_method'] ?? null;\n\n        if ($paymentMethod === 'credit_card') {\n            $rules['card_number'] = [\n                'required',\n                'string',\n                'regex:/^[0-9]{13,19}$/',\n            ];\n\n            $rules['card_holder_name'] = [\n                'required',\n                'string',\n                'max:255',\n            ];\n\n            $rules['expiry_month'] = [\n                'required',\n                'integer',\n                'min:1',\n                'max:12',\n            ];\n\n            $rules['expiry_year'] = [\n                'required',\n                'integer',\n                'min:' . date('Y'),\n                'max:' . (date('Y') + 10),\n            ];\n\n            if ($requireCvv) {\n                $rules['cvv'] = [\n                    'required',\n                    'string',\n                    'regex:/^[0-9]{3,4}$/',\n                ];\n            }\n\n            if ($requireBillingAddress) {\n                $rules['billing_address'] = 'required|string|max:500';\n                $rules['billing_city'] = 'required|string|max:100';\n                $rules['billing_country'] = 'required|string|size:2';\n                $rules['billing_postal_code'] = 'required|string|max:20';\n            }\n        }\n\n        if ($paymentMethod === 'paypal') {\n            $rules['paypal_email'] = [\n                'required',\n                'email',\n            ];\n\n            // Verify PayPal account exists\n            $rules['paypal_email'][] = function ($attribute, $value, $fail) use ($user) {\n                if (!$this->isValidPayPalAccount($value, $user)) {\n                    $fail('The PayPal account is not valid or not linked to your account.');\n                }\n            };\n        }\n\n        // Dynamic amount validation based on order\n        $rules['amount'][] = function ($attribute, $value, $fail) use ($order, $user) {\n            // Check if amount matches order total (with tolerance for fees)\n            $tolerance = 0.01; // 1 cent tolerance\n            if (abs($value - $order->total) > $tolerance) {\n                $fail(\"Payment amount must match order total of {$order->total}\");\n            }\n\n            // Check if user has sufficient balance (for wallet payments)\n            if ($order->payment_method === 'wallet' && $user) {\n                if ($user->wallet_balance < $value) {\n                    $fail('Insufficient wallet balance');\n                }\n            }\n        };\n\n        // Currency validation\n        if (isset($payload['currency'])) {\n            $rules['currency'] = [\n                'required',\n                'string',\n                'in:' . implode(',', $order->supported_currencies ?? ['USD']),\n            ];\n        }\n\n        return $rules;\n    }\n\n    public function messages(FlowTaskContext $context): array\n    {\n        $config = $context->config();\n        $order = $context->subject();\n\n        return [\n            'payment_method.required' => 'Payment method is required',\n            'payment_method.in' => 'Selected payment method is not allowed',\n            'amount.required' => 'Payment amount is required',\n            'amount.numeric' => 'Payment amount must be a number',\n            'amount.min' => \"Payment amount must be at least {$config['min_amount']}\",\n            'amount.max' => \"Payment amount cannot exceed {$order->total}\",\n            'card_number.required' => 'Card number is required',\n            'card_number.regex' => 'Card number format is invalid',\n            'cvv.required' => 'CVV is required for credit card payments',\n            'cvv.regex' => 'CVV must be 3 or 4 digits',\n            'paypal_email.required' => 'PayPal email is required',\n            'paypal_email.email' => 'PayPal email must be a valid email address',\n        ];\n    }\n\n    public function attributes(FlowTaskContext $context): array\n    {\n        return [\n            'payment_method' => 'payment method',\n            'amount' => 'payment amount',\n            'card_number' => 'card number',\n            'card_holder_name' => 'cardholder name',\n            'expiry_month' => 'expiry month',\n            'expiry_year' => 'expiry year',\n            'cvv' => 'CVV',\n            'paypal_email' => 'PayPal email',\n            'billing_address' => 'billing address',\n        ];\n    }\n\n    protected function isValidPayPalAccount(string $email, ?User $user): bool\n    {\n        if (!$user) {\n            return false;\n        }\n\n        // Check if PayPal account is linked to user\n        return $user->paypalAccounts()\n            ->where('email', $email)\n            ->where('verified', true)\n            ->exists();\n    }\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Key Points:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Dynamic rule generation based on payment method"}),"\n",(0,s.jsx)(n.li,{children:"Uses configuration to make validation flexible"}),"\n",(0,s.jsx)(n.li,{children:"Uses subject (order) to get context-specific rules"}),"\n",(0,s.jsx)(n.li,{children:"Custom validation closures for complex logic"}),"\n",(0,s.jsx)(n.li,{children:"Custom messages and attributes for better UX"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"example-4-complex-payload-processing---order-status-update",children:"Example 4: Complex Payload Processing - Order Status Update"}),"\n",(0,s.jsx)(n.p,{children:"Demonstrates comprehensive payload processing with validation and transformation:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-php",children:"namespace App\\Flows\\Order;\n\nuse App\\Models\\Order;\nuse Illuminate\\Support\\Facades\\DB;\nuse Illuminate\\Support\\Facades\\Validator;\nuse JobMetric\\Flow\\Contracts\\AbstractActionTask;\nuse JobMetric\\Flow\\Support\\FlowTaskContext;\n\nclass UpdateOrderStatusActionTask extends AbstractActionTask\n{\n    protected function handle(FlowTaskContext $context): void\n    {\n        $order = $context->subject();\n        $result = $context->result();\n        $payload = $context->payload();\n        $user = $context->user();\n\n        // Extract and validate payload structure\n        $newStatus = $payload['status'] ?? null;\n        $reason = $payload['reason'] ?? 'Status updated';\n        $notes = $payload['notes'] ?? '';\n        $metadata = $payload['metadata'] ?? [];\n        $notifyCustomer = $payload['notify_customer'] ?? true;\n        $updateInventory = $payload['update_inventory'] ?? true;\n        $sendEmail = $payload['send_email'] ?? true;\n\n        // Validate payload structure\n        $validator = Validator::make($payload, [\n            'status' => 'required|string|in:pending,processing,shipped,delivered,cancelled',\n            'reason' => 'nullable|string|max:500',\n            'notes' => 'nullable|string|max:1000',\n            'metadata' => 'nullable|array',\n            'notify_customer' => 'boolean',\n            'update_inventory' => 'boolean',\n        ]);\n\n        if ($validator->fails()) {\n            $result->addError('Invalid payload: ' . $validator->errors()->first());\n            return;\n        }\n\n        // Store old status for audit\n        $oldStatus = $order->status;\n\n        try {\n            DB::beginTransaction();\n\n            // Update order status\n            $order->status = $newStatus;\n            $order->status_changed_at = now();\n            $order->status_changed_by = $user?->id;\n\n            // Update notes if provided\n            if (!empty($notes)) {\n                $order->notes = ($order->notes ? $order->notes . \"\\n\\n\" : '') . \n                    now()->format('Y-m-d H:i:s') . \" - {$notes}\";\n            }\n\n            // Store metadata\n            if (!empty($metadata)) {\n                $existingMetadata = $order->metadata ?? [];\n                $order->metadata = array_merge($existingMetadata, $metadata);\n            }\n\n            $order->save();\n\n            // Update inventory if needed\n            if ($updateInventory && $newStatus === 'cancelled') {\n                $this->restockInventory($order, $result);\n            }\n\n            // Send notifications\n            if ($notifyCustomer && $sendEmail) {\n                $this->sendStatusUpdateEmail($order, $user, $reason, $result);\n            }\n\n            // Log status change\n            $this->logStatusChange($order, $oldStatus, $newStatus, $user, $reason, $result);\n\n            // Update result with complete information\n            $result->addMessage(\"Order status updated from {$oldStatus} to {$newStatus}\")\n                ->addMessage(\"Reason: {$reason}\")\n                ->setData('order_id', $order->id)\n                ->setData('old_status', $oldStatus)\n                ->setData('new_status', $newStatus)\n                ->setData('status_changed_at', $order->status_changed_at->toIso8601String())\n                ->setData('status_changed_by', $user?->id)\n                ->setMeta('inventory_updated', $updateInventory)\n                ->setMeta('customer_notified', $notifyCustomer && $sendEmail)\n                ->setMeta('metadata', $metadata);\n\n            DB::commit();\n\n        } catch (\\Exception $e) {\n            DB::rollBack();\n            $result->addError('Failed to update order status: ' . $e->getMessage());\n        }\n    }\n\n    protected function restockInventory(Order $order, $result): void\n    {\n        foreach ($order->items as $item) {\n            $item->product->increment('stock', $item->quantity);\n            $result->addMessage(\"Restocked {$item->quantity} units of {$item->product->name}\");\n        }\n    }\n\n    protected function sendStatusUpdateEmail(Order $order, $user, $reason, $result): void\n    {\n        // Email sending logic\n        $result->addMessage('Status update email sent');\n    }\n\n    protected function logStatusChange($order, $oldStatus, $newStatus, $user, $reason, $result): void\n    {\n        activity()\n            ->performedOn($order)\n            ->causedBy($user)\n            ->withProperties([\n                'old_status' => $oldStatus,\n                'new_status' => $newStatus,\n                'reason' => $reason,\n            ])\n            ->log('Order status changed');\n\n        $result->setMeta('activity_logged', true);\n    }\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Key Points:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Comprehensive payload extraction with defaults"}),"\n",(0,s.jsx)(n.li,{children:"Payload validation before processing"}),"\n",(0,s.jsx)(n.li,{children:"Uses payload data to control task behavior"}),"\n",(0,s.jsx)(n.li,{children:"Stores payload data in result for tracking"}),"\n",(0,s.jsx)(n.li,{children:"Handles nested payload structures"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"example-5-advanced-user-context-usage---audit-and-authorization",children:"Example 5: Advanced User Context Usage - Audit and Authorization"}),"\n",(0,s.jsx)(n.p,{children:"Demonstrates comprehensive user context usage for audit trails, authorization, and personalization:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-php",children:"namespace App\\Flows\\Order;\n\nuse App\\Models\\Order;\nuse App\\Models\\User;\nuse Illuminate\\Support\\Facades\\Cache;\nuse Illuminate\\Support\\Facades\\Log;\nuse JobMetric\\Flow\\Contracts\\AbstractActionTask;\nuse JobMetric\\Flow\\Support\\FlowTaskContext;\n\nclass AuditOrderActionTask extends AbstractActionTask\n{\n    protected function handle(FlowTaskContext $context): void\n    {\n        $order = $context->subject();\n        $user = $context->user();\n        $result = $context->result();\n        $payload = $context->payload();\n\n        // Always check if user exists\n        if (!$user) {\n            $result->addError('User context is required for audit logging');\n            return;\n        }\n\n        // 1. User-based audit logging\n        $this->logUserAction($order, $user, $payload, $result);\n\n        // 2. User permission verification\n        $this->verifyUserPermissions($order, $user, $result);\n\n        // 3. User-specific notifications\n        $this->sendUserNotifications($order, $user, $result);\n\n        // 4. User preference handling\n        $this->applyUserPreferences($order, $user, $payload, $result);\n\n        // 5. User activity tracking\n        $this->trackUserActivity($order, $user, $result);\n\n        // 6. User-based rate limiting\n        $this->checkUserRateLimit($user, $result);\n    }\n\n    protected function logUserAction(Order $order, User $user, array $payload, $result): void\n    {\n        // Comprehensive audit log\n        $auditData = [\n            'user_id' => $user->id,\n            'user_email' => $user->email,\n            'user_name' => $user->name,\n            'user_roles' => $user->roles->pluck('name')->toArray(),\n            'order_id' => $order->id,\n            'action' => $payload['action'] ?? 'unknown',\n            'ip_address' => request()->ip(),\n            'user_agent' => request()->userAgent(),\n            'timestamp' => now()->toIso8601String(),\n        ];\n\n        // Log to database\n        DB::table('audit_logs')->insert($auditData);\n\n        // Log to file\n        Log::info('Order action performed', $auditData);\n\n        // Store in result\n        $result->setMeta('audit_logged', true)\n            ->setMeta('performed_by', $user->id)\n            ->setMeta('performed_by_email', $user->email)\n            ->setData('audit_id', DB::getPdo()->lastInsertId());\n    }\n\n    protected function verifyUserPermissions(Order $order, User $user, $result): void\n    {\n        // Check ownership\n        if ($order->user_id !== $user->id && !$user->hasRole('admin')) {\n            $result->addError('User does not have permission to perform this action');\n            return;\n        }\n\n        // Check role-based permissions\n        $requiredRole = $result->getData()['required_role'] ?? null;\n        if ($requiredRole && !$user->hasRole($requiredRole)) {\n            $result->addError(\"User must have {$requiredRole} role\");\n            return;\n        }\n\n        $result->addMessage(\"User {$user->id} has required permissions\")\n            ->setMeta('permission_verified', true);\n    }\n\n    protected function sendUserNotifications(Order $order, User $user, $result): void\n    {\n        // Get user notification preferences\n        $preferences = $user->notificationPreferences ?? [];\n\n        // Email notification\n        if ($preferences['email'] ?? true) {\n            Mail::to($user->email)->send(new OrderStatusChanged($order));\n            $result->addMessage(\"Email sent to {$user->email}\");\n        }\n\n        // SMS notification\n        if (($preferences['sms'] ?? false) && $user->phone) {\n            // Send SMS\n            $result->addMessage(\"SMS sent to {$user->phone}\");\n        }\n\n        // In-app notification\n        $user->notify(new OrderStatusChanged($order));\n        $result->addMessage(\"In-app notification sent\");\n\n        $result->setMeta('notifications_sent', true)\n            ->setMeta('user_notification_preferences', $preferences);\n    }\n\n    protected function applyUserPreferences(Order $order, User $user, array $payload, $result): void\n    {\n        // Apply user's language preference\n        $userLanguage = $user->language ?? 'en';\n        app()->setLocale($userLanguage);\n\n        // Apply user's timezone\n        $userTimezone = $user->timezone ?? 'UTC';\n        $result->setMeta('user_timezone', $userTimezone);\n\n        // Apply user's currency preference\n        $userCurrency = $user->currency ?? 'USD';\n        $result->setMeta('user_currency', $userCurrency);\n\n        // Store user preferences in result\n        $result->setData('applied_language', $userLanguage)\n            ->setData('applied_timezone', $userTimezone)\n            ->setData('applied_currency', $userCurrency);\n    }\n\n    protected function trackUserActivity(Order $order, User $user, $result): void\n    {\n        // Track user activity for analytics\n        $activityKey = \"user_activity_{$user->id}\";\n        \n        $activities = Cache::get($activityKey, []);\n        $activities[] = [\n            'order_id' => $order->id,\n            'action' => 'order_processed',\n            'timestamp' => now()->toIso8601String(),\n        ];\n\n        // Keep last 100 activities\n        $activities = array_slice($activities, -100);\n        Cache::put($activityKey, $activities, 3600);\n\n        $result->setMeta('activity_tracked', true)\n            ->setMeta('total_activities', count($activities));\n    }\n\n    protected function checkUserRateLimit(User $user, $result): void\n    {\n        $rateLimitKey = \"user_rate_limit_{$user->id}\";\n        $currentCount = Cache::get($rateLimitKey, 0);\n\n        // Check if user exceeded rate limit\n        $maxActions = 100; // per hour\n        if ($currentCount >= $maxActions) {\n            $result->addError('Rate limit exceeded. Please try again later.');\n            return;\n        }\n\n        // Increment counter\n        Cache::put($rateLimitKey, $currentCount + 1, 3600);\n\n        $result->setMeta('rate_limit_checked', true)\n            ->setMeta('rate_limit_remaining', $maxActions - $currentCount - 1);\n    }\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Key Points:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Always checks if user exists before use"}),"\n",(0,s.jsx)(n.li,{children:"Uses user information for audit trails"}),"\n",(0,s.jsx)(n.li,{children:"Applies user preferences and settings"}),"\n",(0,s.jsx)(n.li,{children:"Tracks user activity"}),"\n",(0,s.jsx)(n.li,{children:"Implements user-based rate limiting"}),"\n",(0,s.jsx)(n.li,{children:"Personalizes experience based on user data"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"example-6-comprehensive-result-management---multi-task-coordination",children:"Example 6: Comprehensive Result Management - Multi-Task Coordination"}),"\n",(0,s.jsx)(n.p,{children:"Demonstrates how multiple tasks coordinate through the shared result object:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-php",children:"namespace App\\Flows\\Order;\n\nuse App\\Models\\Order;\nuse Illuminate\\Support\\Facades\\DB;\nuse JobMetric\\Flow\\Contracts\\AbstractActionTask;\nuse JobMetric\\Flow\\Support\\FlowTaskContext;\n\nclass CoordinateOrderProcessingActionTask extends AbstractActionTask\n{\n    protected function handle(FlowTaskContext $context): void\n    {\n        $order = $context->subject();\n        $result = $context->result(); // Shared across all tasks\n        $config = $context->config();\n        $user = $context->user();\n        $payload = $context->payload();\n\n        // Check if previous tasks succeeded\n        if ($result->hasErrors()) {\n            // Previous task failed, log but continue\n            $result->addMessage('Continuing despite previous errors');\n        }\n\n        // Read data from previous tasks\n        $previousTaskData = $result->getData();\n        $emailSent = $previousTaskData['email_sent'] ?? false;\n        $inventoryUpdated = $previousTaskData['inventory_updated'] ?? false;\n\n        try {\n            // 1. Add informational messages\n            $result->addMessage('Starting order coordination')\n                ->addMessage(\"Order ID: {$order->id}\")\n                ->addMessage(\"User: {$user?->name}\");\n\n            // 2. Set initial data\n            $result->setData('coordination_started_at', now()->toIso8601String())\n                ->setData('order_id', $order->id)\n                ->setData('order_total', $order->total)\n                ->setData('order_status', $order->status);\n\n            // 3. Merge data from payload\n            if (!empty($payload)) {\n                $result->mergeData([\n                    'payload_reason' => $payload['reason'] ?? null,\n                    'payload_notes' => $payload['notes'] ?? null,\n                ]);\n            }\n\n            // 4. Process based on previous task results\n            if ($emailSent) {\n                $result->addMessage('Email was sent by previous task');\n            } else {\n                $result->addMessage('Email was not sent, sending now');\n                $this->sendEmail($order, $user, $result);\n            }\n\n            // 5. Add execution metadata\n            $startTime = microtime(true);\n            \n            // Perform operations\n            $this->performOperations($order, $result);\n\n            $executionTime = microtime(true) - $startTime;\n            $result->setMeta('execution_time', round($executionTime, 4))\n                ->setMeta('memory_usage', memory_get_peak_usage(true))\n                ->setMeta('tasks_coordinated', true);\n\n            // 6. Aggregate all messages for final summary\n            $allMessages = $result->getMessages();\n            $result->addMessage(\"Coordination complete. Total messages: \" . count($allMessages));\n\n            // 7. Final data aggregation\n            $allData = $result->getData();\n            $result->setData('total_data_points', count($allData))\n                ->setData('coordination_completed_at', now()->toIso8601String());\n\n        } catch (\\Exception $e) {\n            // Add error but don't fail entire transition\n            $result->addError('Coordination failed: ' . $e->getMessage(), false)\n                ->setMeta('coordination_error', $e->getMessage())\n                ->setMeta('coordination_error_class', get_class($e));\n        }\n    }\n\n    protected function sendEmail(Order $order, $user, $result): void\n    {\n        // Email sending logic\n        $result->setData('email_sent', true)\n            ->addMessage('Email sent during coordination');\n    }\n\n    protected function performOperations(Order $order, $result): void\n    {\n        // Operations that update result\n        $result->addMessage('Operations performed')\n            ->setData('operations_completed', true);\n    }\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Key Points:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Reads data from previous tasks via shared result"}),"\n",(0,s.jsx)(n.li,{children:"Coordinates multiple tasks through result object"}),"\n",(0,s.jsx)(n.li,{children:"Aggregates information from all tasks"}),"\n",(0,s.jsx)(n.li,{children:"Handles errors gracefully"}),"\n",(0,s.jsx)(n.li,{children:"Tracks execution metrics"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"example-7-configuration-management---testing-and-overrides",children:"Example 7: Configuration Management - Testing and Overrides"}),"\n",(0,s.jsx)(n.p,{children:"Demonstrates advanced configuration usage, including testing scenarios and dynamic configuration:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-php",children:"namespace App\\Flows\\Order;\n\nuse App\\Models\\Order;\nuse JobMetric\\Flow\\Contracts\\AbstractActionTask;\nuse JobMetric\\Flow\\Support\\FlowTaskContext;\n\nclass ConfigurableEmailActionTask extends AbstractActionTask\n{\n    protected function handle(FlowTaskContext $context): void\n    {\n        $order = $context->subject();\n        $result = $context->result();\n        $config = $context->config(); // Cached, no DB call\n\n        // Get configuration with intelligent defaults\n        $emailTo = $config['email_to'] ?? $order->customer_email;\n        $template = $config['template'] ?? 'order-status';\n        $subject = $config['subject'] ?? \"Order #{$order->id} Status Update\";\n        $cc = $config['cc'] ?? [];\n        $bcc = $config['bcc'] ?? [];\n        $attachInvoice = $config['attach_invoice'] ?? false;\n        $priority = $config['priority'] ?? 'normal';\n\n        // Use configuration\n        Mail::to($emailTo)\n            ->cc($cc)\n            ->bcc($bcc)\n            ->send(new OrderStatusChanged($order, $template, $subject));\n\n        $result->addMessage(\"Email sent to {$emailTo}\")\n            ->setData('email_config', [\n                'to' => $emailTo,\n                'template' => $template,\n                'subject' => $subject,\n            ]);\n    }\n}\n\n// Usage in Production\n// Configuration is loaded from database (task config)\n$context = new FlowTaskContext($order, $result, $payload, $user);\n// Config is automatically loaded from FlowTask model\n\n// Usage in Tests\n$context = new FlowTaskContext($order, $result, $payload, $user);\n$context->replaceConfig([\n    'email_to' => 'test@example.com',\n    'template' => 'test-template',\n    'subject' => 'Test Email',\n    'attach_invoice' => false,\n]);\n$task->handle($context);\n\n// Usage with Dynamic Configuration\n$context = new FlowTaskContext($order, $result, $payload, $user);\n\n// Override config based on order type\n$config = $context->config();\nif ($order->is_premium) {\n    $config['template'] = 'premium-order-status';\n    $config['priority'] = 'high';\n}\n$context->replaceConfig($config);\n\n$task->handle($context);\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Key Points:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Configuration is cached (no DB calls during execution)"}),"\n",(0,s.jsx)(n.li,{children:"Can be overridden for testing"}),"\n",(0,s.jsx)(n.li,{children:"Supports intelligent defaults"}),"\n",(0,s.jsx)(n.li,{children:"Can be modified dynamically based on context"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"real-world-complete-system-example",children:"Real-World Complete System Example"}),"\n",(0,s.jsx)(n.h3,{id:"complete-order-cancellation-workflow",children:"Complete Order Cancellation Workflow"}),"\n",(0,s.jsx)(n.p,{children:"A complete example showing how all context components work together in a real workflow:"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"1. Restriction Task - Check if cancellation is allowed:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-php",children:"class RestrictCancellationRestrictionTask extends AbstractRestrictionTask\n{\n    public function restriction(FlowTaskContext $context): RestrictionResult\n    {\n        $order = $context->subject();\n        $user = $context->user();\n        $payload = $context->payload();\n        $config = $context->config();\n        $result = $context->result();\n\n        // Check user\n        if (!$user) {\n            return RestrictionResult::deny('USER_REQUIRED', 'User must be authenticated');\n        }\n\n        // Check permission\n        if (!$user->can('cancel', $order)) {\n            $result->addMessage(\"User {$user->id} lacks cancel permission\");\n            return RestrictionResult::deny('PERMISSION_DENIED', 'No permission');\n        }\n\n        // Check reason from payload\n        if (($config['require_reason'] ?? true) && empty($payload['reason'])) {\n            return RestrictionResult::deny('REASON_REQUIRED', 'Reason required');\n        }\n\n        // Check order status\n        if ($order->status === 'shipped') {\n            $result->addMessage(\"Order {$order->id} is shipped, cannot cancel\");\n            return RestrictionResult::deny('ORDER_SHIPPED', 'Cannot cancel shipped orders');\n        }\n\n        $result->addMessage(\"Cancellation allowed for order {$order->id}\");\n        return RestrictionResult::allow();\n    }\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"2. Validation Task - Validate cancellation data:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-php",children:"class ValidateCancellationValidationTask extends AbstractValidationTask\n{\n    public function rules(FlowTaskContext $context): array\n    {\n        $payload = $context->payload();\n        $order = $context->subject();\n        $config = $context->config();\n\n        return [\n            'reason' => [\n                'required',\n                'string',\n                'min:10',\n                'max:500',\n            ],\n            'refund_method' => [\n                'required',\n                'string',\n                'in:original,store_credit',\n            ],\n            'restock_inventory' => [\n                'boolean',\n            ],\n        ];\n    }\n\n    public function messages(FlowTaskContext $context): array\n    {\n        return [\n            'reason.required' => 'Cancellation reason is required',\n            'reason.min' => 'Reason must be at least 10 characters',\n            'refund_method.required' => 'Refund method must be selected',\n        ];\n    }\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"3. Action Task - Execute cancellation:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-php",children:"class CancelOrderActionTask extends AbstractActionTask\n{\n    protected function handle(FlowTaskContext $context): void\n    {\n        $order = $context->subject();\n        $user = $context->user();\n        $payload = $context->payload();\n        $config = $context->config();\n        $result = $context->result();\n\n        // Extract payload\n        $reason = $payload['reason'];\n        $refundMethod = $payload['refund_method'];\n        $restockInventory = $payload['restock_inventory'] ?? true;\n\n        try {\n            DB::beginTransaction();\n\n            // 1. Update order status\n            $order->status = 'cancelled';\n            $order->cancelled_at = now();\n            $order->cancelled_by = $user->id;\n            $order->cancellation_reason = $reason;\n            $order->save();\n\n            // 2. Process refund\n            $this->processRefund($order, $refundMethod, $result);\n\n            // 3. Restock inventory\n            if ($restockInventory) {\n                $this->restockInventory($order, $result);\n            }\n\n            // 4. Send notifications\n            $this->sendNotifications($order, $user, $reason, $result);\n\n            // 5. Update result\n            $result->addMessage('Order cancelled successfully')\n                ->addMessage(\"Reason: {$reason}\")\n                ->setData('order_id', $order->id)\n                ->setData('cancelled_at', $order->cancelled_at->toIso8601String())\n                ->setData('cancelled_by', $user->id)\n                ->setData('refund_method', $refundMethod)\n                ->setMeta('inventory_restocked', $restockInventory);\n\n            DB::commit();\n\n        } catch (\\Exception $e) {\n            DB::rollBack();\n            $result->addError('Cancellation failed: ' . $e->getMessage());\n        }\n    }\n\n    protected function processRefund(Order $order, string $method, $result): void\n    {\n        // Refund logic\n        $result->addMessage(\"Refund processed via {$method}\");\n    }\n\n    protected function restockInventory(Order $order, $result): void\n    {\n        // Restock logic\n        $result->addMessage('Inventory restocked');\n    }\n\n    protected function sendNotifications(Order $order, $user, string $reason, $result): void\n    {\n        // Notification logic\n        $result->addMessage('Notifications sent');\n    }\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"4. Usage in Controller:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-php",children:"namespace App\\Http\\Controllers;\n\nuse App\\Models\\Order;\nuse Illuminate\\Http\\Request;\nuse JobMetric\\Flow\\Facades\\FlowTransition;\n\nclass OrderController extends Controller\n{\n    public function cancel(Request $request, Order $order)\n    {\n        // Prepare payload\n        $payload = [\n            'reason' => $request->input('reason'),\n            'refund_method' => $request->input('refund_method'),\n            'restock_inventory' => $request->boolean('restock_inventory', true),\n        ];\n\n        // Execute transition\n        $result = FlowTransition::runner('cancel_order', $order, $payload, auth()->user());\n\n        if ($result->isSuccess()) {\n            return response()->json([\n                'success' => true,\n                'message' => 'Order cancelled successfully',\n                'data' => $result->getData(),\n            ]);\n        }\n\n        return response()->json([\n            'success' => false,\n            'errors' => $result->getErrors(),\n            'messages' => $result->getMessages(),\n        ], 400);\n    }\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Flow of Context Through Tasks:"})}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Restriction Task"})," receives context:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Reads ",(0,s.jsx)(n.code,{children:"subject()"})," (order)"]}),"\n",(0,s.jsxs)(n.li,{children:["Reads ",(0,s.jsx)(n.code,{children:"user()"})," (permission check)"]}),"\n",(0,s.jsxs)(n.li,{children:["Reads ",(0,s.jsx)(n.code,{children:"payload()"})," (reason check)"]}),"\n",(0,s.jsxs)(n.li,{children:["Reads ",(0,s.jsx)(n.code,{children:"config()"})," (require_reason setting)"]}),"\n",(0,s.jsxs)(n.li,{children:["Writes to ",(0,s.jsx)(n.code,{children:"result()"})," (messages for debugging)"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Validation Task"})," receives same context:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Reads ",(0,s.jsx)(n.code,{children:"payload()"})," (validation rules)"]}),"\n",(0,s.jsxs)(n.li,{children:["Reads ",(0,s.jsx)(n.code,{children:"subject()"})," (order for context)"]}),"\n",(0,s.jsxs)(n.li,{children:["Validation errors go to ",(0,s.jsx)(n.code,{children:"result()"})]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Action Task"})," receives same context:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Reads ",(0,s.jsx)(n.code,{children:"subject()"})," (order to update)"]}),"\n",(0,s.jsxs)(n.li,{children:["Reads ",(0,s.jsx)(n.code,{children:"user()"})," (who cancelled)"]}),"\n",(0,s.jsxs)(n.li,{children:["Reads ",(0,s.jsx)(n.code,{children:"payload()"})," (reason, refund method)"]}),"\n",(0,s.jsxs)(n.li,{children:["Reads ",(0,s.jsx)(n.code,{children:"config()"})," (task settings)"]}),"\n",(0,s.jsxs)(n.li,{children:["Writes to ",(0,s.jsx)(n.code,{children:"result()"})," (success messages, data, metadata)"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Key Insight:"})," All tasks share the ",(0,s.jsx)(n.strong,{children:"same"})," ",(0,s.jsx)(n.code,{children:"TransitionResult"})," object. This means:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Messages from restriction task are visible in action task"}),"\n",(0,s.jsx)(n.li,{children:"Data set by one task can be read by another"}),"\n",(0,s.jsx)(n.li,{children:"Errors accumulate across all tasks"}),"\n",(0,s.jsx)(n.li,{children:"Final result contains complete workflow outcome"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"integration-with-flowtransition",children:"Integration with FlowTransition"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"FlowTransition"})," service creates ",(0,s.jsx)(n.code,{children:"FlowTaskContext"})," instances automatically and passes the same context to all tasks:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-php",children:"// Inside FlowTransition::runner()\n$transitionResult = TransitionResult::success();\n$context = new FlowTaskContext($subject, $transitionResult, $payload, $user);\n\n// All tasks receive the SAME context instance\n$restrictionTask->restriction($context);  // Can read/write result\n$validationTask->rules($context);        // Can read result from restriction\n$actionTask->handle($context);           // Can read result from all previous tasks\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Important:"})," The context is created once and shared. This allows tasks to coordinate and build upon each other's work."]}),"\n",(0,s.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Always Check User"}),": Check if user exists before accessing:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-php",children:"$user = $context->user();\nif ($user) {\n    // Use user\n}\n"})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Use Result Object"}),": Always use ",(0,s.jsx)(n.code,{children:"$context->result()"})," to add messages/errors:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-php",children:"$context->result()->addMessage('Task completed');\n"})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Validate Payload"}),": Always validate payload data:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-php",children:"$payload = $context->payload();\n$value = $payload['key'] ?? null;\n"})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Cache Configuration"}),": Use ",(0,s.jsx)(n.code,{children:"replaceConfig()"})," to avoid database calls in tests"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Type Hints"}),": Use proper type hints when accessing context:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-php",children:"/** @var Order $order */\n$order = $context->subject();\n"})}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"related-documentation",children:"Related Documentation"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"/packages/laravel-flow/deep-diving/transition-result",children:"TransitionResult"})," - Transition result DTO"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"/packages/laravel-flow/deep-diving/support/restriction-result",children:"RestrictionResult"})," - Restriction task results"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"/packages/laravel-flow/deep-diving/services/flow-transition",children:"FlowTransition Service"})," - Transition execution"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"/packages/laravel-flow/deep-diving/support/flow-task-registry",children:"FlowTaskRegistry"})," - Task driver registry"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"/packages/laravel-flow/deep-diving/make-task",children:"MakeTask Command"})," - Generating task drivers"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"/packages/laravel-flow/deep-diving/services/flow-task",children:"FlowTask Service"})," - Task management"]}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},8453(e,n,t){t.d(n,{R:()=>i,x:()=>o});var r=t(6540);const s={},a=r.createContext(s);function i(e){const n=r.useContext(a);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),r.createElement(a.Provider,{value:n},e.children)}}}]);